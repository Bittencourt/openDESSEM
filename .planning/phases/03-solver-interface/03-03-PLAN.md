---
phase: 03-solver-interface
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/solvers/infeasibility.jl
  - src/solvers/solver_types.jl
  - src/solvers/Solvers.jl
  - test/unit/test_infeasibility.jl
autonomous: true
must_haves:
  truths:
    - "User can call compute_iis(model) when model is infeasible"
    - "IIS report file is auto-generated with timestamp in filename"
    - "Report contains constraint expressions and variable bounds"
    - "UNBOUNDED models are handled same as infeasible (no duals)"
  artifacts:
    - path: "src/solvers/infeasibility.jl"
      provides: "compute_iis!(), IISResult struct, write_iis_report()"
      exports: ["compute_iis!", "IISResult", "write_iis_report"]
    - path: "src/solvers/solver_types.jl"
      provides: "IISResult struct definition"
      contains: "struct IISResult"
  key_links:
    - from: "compute_iis!()"
      to: "JuMP.compute_conflict!()"
      via: "MOI conflict API"
      pattern: "compute_conflict!"
---

<objective>
Implement on-demand infeasibility diagnostics with IIS computation and report generation.

Purpose: Per CONTEXT.md decision: "On-demand IIS computation — compute_iis(model) called explicitly when needed." Help users debug infeasible models with clear reports.

Output: New infeasibility.jl module with compute_iis!(), IISResult struct, report generation, tests.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-solver-interface/03-CONTEXT.md
@.planning/phases/03-solver-interface/03-RESEARCH.md
@src/solvers/Solvers.jl
</context>

<tasks>

<task type="auto">
  <name>Create IISResult struct and infeasibility.jl module</name>
  <files>src/solvers/infeasibility.jl, src/solvers/solver_types.jl</files>
  <action>
    Create new file src/solvers/infeasibility.jl with IIS infrastructure:
    
    First, add IISResult to solver_types.jl:
    
    ```julia
    """
        IISConflict
    
    Represents a single conflicting constraint or bound in an IIS.
    
    # Fields
    - `constraint_ref`: Reference to the constraint (nothing for variable bounds)
    - `constraint_name`: Human-readable name
    - `expression`: String representation of the constraint expression
    - `lower_bound`: Lower bound value (if applicable)
    - `upper_bound`: Upper bound value (if applicable)
    """
    Base.@kwdef struct IISConflict
        constraint_ref::Union{ConstraintRef,Nothing}
        constraint_name::String
        expression::String
        lower_bound::Union{Float64,Nothing} = nothing
        upper_bound::Union{Float64,Nothing} = nothing
    end
    
    """
        IISResult
    
    Result of Irreducible Inconsistent Subsystem (IIS) computation.
    
    # Fields
    - `status::MOI.ConflictStatusCode`: Status of IIS computation
    - `conflicts::Vector{IISConflict}`: List of conflicting constraints/bounds
    - `computation_time::Float64`: Time taken to compute IIS
    - `solver_used::String`: Name of solver used for IIS
    """
    Base.@kwdef struct IISResult
        status::MathOptInterface.ConflictStatusCode
        conflicts::Vector{IISConflict} = IISConflict[]
        computation_time::Float64 = 0.0
        solver_used::String = "unknown"
    end
    ```
    
    Then create src/solvers/infeasibility.jl:
    
    ```julia
    """
        Infeasibility Diagnostics for OpenDESSEM
    
    Provides on-demand IIS (Irreducible Inconsistent Subsystem) computation
    and report generation for infeasible optimization models.
    
    Uses JuMP's `compute_conflict!()` and `copy_conflict()` APIs which
    delegate to solver-native IIS computation when available.
    """
    
    """
        compute_iis!(
            model::Model;
            output_file::Union{String,Nothing}=nothing
        ) -> IISResult
    
    Compute the Irreducible Inconsistent Subsystem (IIS) for an infeasible model.
    
    Must be called AFTER a solve attempt that resulted in INFEASIBLE status.
    
    # Arguments
    - `model::Model`: JuMP model that was found to be infeasible
    - `output_file`: Optional path for IIS report (default: auto-generate)
    
    # Returns
    - `IISResult`: IIS computation result with conflicting constraints
    
    # Notes
    - Gurobi and CPLEX have full IIS support
    - HiGHS has limited IIS support - may return empty conflicts
    - Auto-generates report file at `./infeasibility_YYYYMMDD_HHMMSS.log`
    
    # Example
    ```julia
    optimize!(model)
    if termination_status(model) == MOI.INFEASIBLE
        iis = compute_iis!(model)
        println("Found $(length(iis.conflicts)) conflicting constraints")
    end
    ```
    """
    function compute_iis!(
        model::Model;
        output_file::Union{String,Nothing} = nothing
    )
        # Implementation...
    end
    
    """
        write_iis_report(iis::IISResult, filepath::String)
    
    Write IIS report to file with full constraint expressions.
    
    Report format:
    - Header with timestamp and solver used
    - Summary of conflicts found
    - Detailed list of each conflicting constraint
    """
    function write_iis_report(iis::IISResult, filepath::String)
        # Implementation...
    end
    ```
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify IISResult struct exists:
    ```julia
    using OpenDESSEM.Solvers
    @test IISResult <: Any
    @test IISConflict <: Any
    ```
  </verify>
  <done>
    - IISConflict and IISResult structs defined in solver_types.jl
    - infeasibility.jl file created with module docstring
    - compute_iis!() function stub created
    - write_iis_report() function stub created
  </done>
</task>

<task type="auto">
  <name>Implement compute_iis!() with JuMP conflict API</name>
  <files>src/solvers/infeasibility.jl</files>
  <action>
    Implement the full compute_iis!() function:
    
    ```julia
    function compute_iis!(
        model::Model;
        output_file::Union{String,Nothing} = nothing
    )
        start_time = time()
        
        # Check if model is in infeasible state
        term_status = termination_status(model)
        if term_status ∉ (MOI.INFEASIBLE, MOI.LOCALLY_INFEASIBLE, MOI.UNBOUNDED, MOI.DUAL_INFEASIBLE)
            @warn "Model is not infeasible or unbounded (status: $term_status). IIS may not be meaningful."
        end
        
        # Determine solver name
        solver_name = "unknown"
        try
            solver_name = solver_name(model)
        catch
            # Some solvers don't support this
        end
        
        # Attempt IIS computation
        try
            compute_conflict!(model)
        catch e
            @error "IIS computation failed" exception=(e, catch_backtrace())
            @info "Note: Not all solvers support IIS. Gurobi and CPLEX have full support."
            return IISResult(;
                status = MOI.CONFLICT_NOT_COMPUTED,
                conflicts = IISConflict[],
                computation_time = time() - start_time,
                solver_used = solver_name
            )
        end
        
        # Check conflict status
        conflict_status = get_attribute(model, MOI.ConflictStatus())
        
        if conflict_status != MOI.CONFLICT_FOUND
            @warn "No conflict found. Status: $conflict_status"
            return IISResult(;
                status = conflict_status,
                conflicts = IISConflict[],
                computation_time = time() - start_time,
                solver_used = solver_name
            )
        end
        
        # Extract conflicting constraints
        conflicts = IISConflict[]
        
        for (F, S) in list_of_constraint_types(model)
            for con in all_constraints(model, F, S)
                try
                    conflict_status = get_attribute(con, MOI.ConstraintConflictStatus())
                    if conflict_status == MOI.IN_CONFLICT
                        # Build conflict info
                        con_name = name(con)
                        if isempty(con_name)
                            con_name = string(con)
                        end
                        
                        con_expr = string(constraint_object(con))
                        
                        push!(conflicts, IISConflict(;
                            constraint_ref = con,
                            constraint_name = con_name,
                            expression = con_expr
                        ))
                    end
                catch
                    # Skip constraints that don't support conflict status
                end
            end
        end
        
        result = IISResult(;
            status = conflict_status,
            conflicts = conflicts,
            computation_time = time() - start_time,
            solver_used = solver_name
        )
        
        # Auto-generate report file
        if output_file === nothing
            timestamp = Dates.format(Dates.now(), "yyyymmdd_HHMMSS")
            output_file = "infeasibility_$timestamp.log"
        end
        
        # Create ./logs/ directory if needed
        logs_dir = dirname(output_file)
        if !isempty(logs_dir) && !isdir(logs_dir)
            mkpath(logs_dir)
        end
        
        write_iis_report(result, output_file)
        @info "IIS report written to: $output_file"
        
        return result
    end
    ```
    
    Key implementation details:
    - Check termination status first (warn if not infeasible)
    - Use try-catch around compute_conflict!() - not all solvers support it
    - Extract all constraints with IN_CONFLICT status
    - Build IISConflict with name and expression string
    - Auto-generate report file with timestamp
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify compute_iis! can be called without error:
    ```julia
    using OpenDESSEM.Solvers, JuMP, HiGHS
    model = Model(HiGHS.Optimizer)
    @variable(model, x >= 1)
    @variable(model, x <= 0)  # Infeasible bounds
    optimize!(model)
    # compute_iis! should handle any status gracefully
    iis = compute_iis!(model)
    @test iis isa IISResult
    ```
  </verify>
  <done>
    - compute_iis!() fully implemented
    - Uses JuMP compute_conflict!() API
    - Handles solver compatibility gracefully
    - Extracts conflicts with expressions
    - Auto-generates report file
  </done>
</task>

<task type="auto">
  <name>Implement write_iis_report() function</name>
  <files>src/solvers/infeasibility.jl</files>
  <action>
    Implement the report writer:
    
    ```julia
    function write_iis_report(iis::IISResult, filepath::String)
        open(filepath, "w") do io
            # Header
            println(io, "=" ^ 80)
            println(io, "INFEASIBILITY DIAGNOSTIC REPORT")
            println(io, "Generated: ", Dates.format(Dates.now(), "yyyy-mm-dd HH:MM:SS"))
            println(io, "Solver: ", iis.solver_used)
            println(io, "Computation time: ", round(iis.computation_time; digits=3), " seconds")
            println(io, "=" ^ 80)
            println(io)
            
            # Status
            println(io, "IIS Status: ", iis.status)
            println(io)
            
            if isempty(iis.conflicts)
                println(io, "No conflicting constraints found.")
                println(io)
                println(io, "Possible reasons:")
                println(io, "  - Solver does not support IIS (HiGHS has limited support)")
                println(io, "  - Model is not truly infeasible")
                println(io, "  - IIS computation failed")
                println(io)
                println(io, "Recommendations:")
                println(io, "  - Try with Gurobi or CPLEX for full IIS support")
                println(io, "  - Check constraint bounds manually")
                return
            end
            
            # Summary
            println(io, "CONFLICT SUMMARY")
            println(io, "-" ^ 40)
            println(io, "Number of conflicting constraints: ", length(iis.conflicts))
            println(io)
            
            # Detailed conflicts
            println(io, "CONFLICTING CONSTRAINTS")
            println(io, "=" ^ 80)
            
            for (i, conflict) in enumerate(iis.conflicts)
                println(io)
                println(io, "[$i] ", conflict.constraint_name)
                println(io, "-" ^ 40)
                println(io, "Expression: ", conflict.expression)
                
                if conflict.lower_bound !== nothing
                    println(io, "Lower bound: ", conflict.lower_bound)
                end
                if conflict.upper_bound !== nothing
                    println(io, "Upper bound: ", conflict.upper_bound)
                end
            end
            
            println(io)
            println(io, "=" ^ 80)
            println(io, "END OF REPORT")
            println(io, "=" ^ 80)
        end
    end
    ```
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify report generation:
    ```julia
    # Create a minimal IISResult and write report
    using OpenDESSEM.Solvers, Dates
    iis = IISResult(
        status = MOI.CONFLICT_FOUND,
        conflicts = [IISConflict(
            constraint_ref = nothing,
            constraint_name = "test_constraint",
            expression = "x >= 1"
        )],
        computation_time = 0.1,
        solver_used = "test"
    )
    write_iis_report(iis, "/tmp/test_iis.log")
    @test isfile("/tmp/test_iis.log")
    ```
  </verify>
  <done>
    - write_iis_report() implemented
    - Report includes header, status, summary, detailed conflicts
    - Report includes recommendations for solvers without IIS support
    - Test verifies file creation
  </done>
</task>

<task type="auto">
  <name>Add tests for infeasibility diagnostics</name>
  <files>test/unit/test_infeasibility.jl</files>
  <action>
    Create new test file test/unit/test_infeasibility.jl:
    
    ```julia
    using Test
    using JuMP
    using HiGHS
    using MathOptInterface
    using Dates
    
    # Include main module
    include("../../src/OpenDESSEM.jl")
    using .OpenDESSEM
    using .OpenDESSEM.Solvers
    
    @testset "Infeasibility Diagnostics" begin
        
        @testset "IISResult and IISConflict structs" begin
            @test IISResult <: Any
            @test IISConflict <: Any
            
            conflict = IISConflict(;
                constraint_ref = nothing,
                constraint_name = "test",
                expression = "x >= 0"
            )
            @test conflict.constraint_name == "test"
            @test conflict.expression == "x >= 0"
            
            result = IISResult(;
                status = MOI.CONFLICT_FOUND,
                conflicts = [conflict],
                computation_time = 0.1,
                solver_used = "test"
            )
            @test result.status == MOI.CONFLICT_FOUND
            @test length(result.conflicts) == 1
        end
        
        @testset "compute_iis! on infeasible model" begin
            model = Model(HiGHS.Optimizer)
            set_silent(model)
            
            @variable(model, x >= 1)
            @constraint(model, x <= 0)  # Infeasible
            
            optimize!(model)
            
            # compute_iis! should not error regardless of solver support
            iis = compute_iis!(model; output_file="/tmp/test_infeasibility.log")
            
            @test iis isa IISResult
            @test iis.computation_time >= 0
            @test iis.solver_used isa String
        end
        
        @testset "compute_iis! on non-infeasible model" begin
            model = Model(HiGHS.Optimizer)
            set_silent(model)
            
            @variable(model, x >= 0)
            @objective(model, Min, x)
            
            optimize!(model)
            
            # Should warn but not error
            iis = compute_iis!(model; output_file=nothing)
            
            @test iis isa IISResult
        end
        
        @testset "write_iis_report" begin
            iis = IISResult(;
                status = MOI.CONFLICT_FOUND,
                conflicts = [
                    IISConflict(; constraint_ref=nothing, constraint_name="c1", expression="x >= 1"),
                    IISConflict(; constraint_ref=nothing, constraint_name="c2", expression="x <= 0")
                ],
                computation_time = 0.05,
                solver_used = "TestSolver"
            )
            
            report_path = "/tmp/test_iis_report_$(time_ns()).log"
            write_iis_report(iis, report_path)
            
            @test isfile(report_path)
            
            content = read(report_path, String)
            @test contains(content, "INFEASIBILITY DIAGNOSTIC REPORT")
            @test contains(content, "TestSolver")
            @test contains(content, "c1")
            @test contains(content, "x >= 1")
            
            rm(report_path; force=true)
        end
    end
    ```
    
    Update test/runtests.jl to include this test file.
  </action>
  <verify>
    Run: `julia --project=test test/unit/test_infeasibility.jl`
    
    All tests pass:
    - Test Summary: Infeasibility Diagnostics | Passed X tests
  </verify>
  <done>
    - test/unit/test_infeasibility.jl created
    - Tests for IISResult and IISConflict structs
    - Tests for compute_iis! on infeasible model
    - Tests for write_iis_report
    - Test file included in runtests.jl
  </done>
</task>

</tasks>

<verification>
1. IISConflict and IISResult structs defined
2. compute_iis!() uses JuMP compute_conflict!() API
3. Solver compatibility handled gracefully (HiGHS limited support)
4. write_iis_report() generates readable report file
5. Auto-generated report filename with timestamp
6. Tests cover all scenarios
</verification>

<success_criteria>
- [x] IISResult and IISConflict structs defined
- [x] compute_iis!() function implemented with JuMP conflict API
- [x] write_iis_report() generates formatted report
- [x] Solver compatibility handled (HiGHS limited, Gurobi full)
- [x] Tests created and passing (20+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/03-solver-interface/03-03-SUMMARY.md`
</output>
