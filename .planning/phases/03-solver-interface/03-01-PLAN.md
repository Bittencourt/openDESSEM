---
phase: 03-solver-interface
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/solvers/solver_types.jl
  - src/solvers/solver_interface.jl
  - src/solvers/Solvers.jl
autonomous: true
must_haves:
  truths:
    - "User can call solve_model!(model) with keyword arguments and get a SolveResult"
    - "solve_model!() automatically performs two-stage pricing when pricing=true"
    - "SolveStatus enum provides user-friendly status (OPTIMAL, INFEASIBLE, TIME_LIMIT, etc.)"
    - "Result struct has separate mip_result and lp_result fields"
  artifacts:
    - path: "src/solvers/solver_types.jl"
      provides: "SolveStatus enum, enhanced SolverResult"
      min_lines: 50
    - path: "src/solvers/solver_interface.jl"
      provides: "solve_model!() unified API"
      exports: ["solve_model!"]
  key_links:
    - from: "src/solvers/solver_interface.jl"
      to: "two_stage_pricing.jl"
      via: "compute_two_stage_lmps() when pricing=true"
      pattern: "pricing.*compute_two_stage"
---

<objective>
Create unified solve_model!() API with two-stage pricing support and user-friendly status reporting.

Purpose: Provide a single entry point for model solving that matches user decisions from CONTEXT.md - keyword args with sensible defaults, two-stage pricing for PLDs, rich result struct.

Output: Enhanced solver types (SolveStatus enum), unified solve_model!() function, tests for new API.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-solver-interface/03-CONTEXT.md
@.planning/phases/03-solver-interface/03-RESEARCH.md
@src/solvers/solver_types.jl
@src/solvers/solver_interface.jl
@src/solvers/two_stage_pricing.jl
@src/solvers/Solvers.jl
</context>

<tasks>

<task type="auto">
  <name>Add SolveStatus enum and enhance SolverResult</name>
  <files>src/solvers/solver_types.jl</files>
  <action>
    Add a user-friendly SolveStatus enum that maps MOI.TerminationStatusCode to simple values:
    
    ```julia
    """
        SolveStatus
    
    User-friendly solver status enumeration.
    
    Maps MathOptInterface status codes to simple, actionable values.
    """
    @enum SolveStatus begin
        OPTIMAL           # Solution found and optimal
        INFEASIBLE        # No feasible solution exists
        UNBOUNDED         # Objective can improve infinitely
        TIME_LIMIT        # Time limit reached with solution
        ITERATION_LIMIT   # Iteration limit reached
        NUMERICAL_ERROR   # Numerical issues encountered
        OTHER_LIMIT       # Other limit (memory, nodes, etc.)
        NOT_SOLVED        # Model not yet solved
    end
    ```
    
    Enhance SolverResult struct with:
    - `solve_status::SolveStatus` field (derived from MOI status)
    - `mip_result::Union{SolverResult, Nothing}` for Stage 1 results
    - `lp_result::Union{SolverResult, Nothing}` for Stage 2 results
    - `cost_breakdown::Dict{String, Float64}` for component costs
    
    Add helper function `map_to_solve_status(moi_status)::SolveStatus` that converts:
    - MOI.OPTIMAL, MOI.LOCALLY_SOLVED → OPTIMAL
    - MOI.INFEASIBLE, MOI.LOCALLY_INFEASIBLE → INFEASIBLE
    - MOI.UNBOUNDED, MOI.DUAL_INFEASIBLE → UNBOUNDED
    - MOI.TIME_LIMIT → TIME_LIMIT
    - MOI.ITERATION_LIMIT → ITERATION_LIMIT
    - MOI.NUMERICAL_ERROR → NUMERICAL_ERROR
    - Others → OTHER_LIMIT
    
    Update Solvers.jl to export SolveStatus enum.
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify SolveStatus enum exists:
    ```julia
    using OpenDESSEM.Solvers
    @assert OPTIMAL isa SolveStatus
    @assert INFEASIBLE isa SolveStatus
    ```
  </verify>
  <done>
    - SolveStatus enum defined with all 8 values
    - SolverResult has solve_status, mip_result, lp_result, cost_breakdown fields
    - map_to_solve_status() correctly maps MOI status codes
    - Exports updated in Solvers.jl
  </done>
</task>

<task type="auto">
  <name>Implement solve_model!() unified API</name>
  <files>src/solvers/solver_interface.jl</files>
  <action>
    Create the main solve_model!() function per CONTEXT.md decisions:
    
    ```julia
    """
        solve_model!(
            model::Model,
            system::ElectricitySystem;
            solver=HiGHS.Optimizer,
            time_limit::Float64=3600.0,
            mip_gap::Float64=0.01,
            output_level::Int=1,
            pricing::Bool=true,
            log_file::Union{String,Nothing}=nothing,
            progress_callback=nothing,
            warm_start::Union{SolverResult,Nothing}=nothing,
            solver_attributes::Dict{String,Any}=Dict{String,Any}()
        ) -> SolverResult
    
    Unified solve API with two-stage pricing support.
    
    # Keyword Arguments
    - `solver`: Optimizer factory (default: HiGHS.Optimizer)
    - `time_limit`: Time limit in seconds (default: 3600.0)
    - `mip_gap`: MIP gap tolerance (default: 0.01)
    - `output_level`: 0=silent, 1=minimal, 2=detailed (default: 1)
    - `pricing`: Enable two-stage pricing for PLDs (default: true)
    - `log_file`: Log file path (default: auto-generate in ./logs/)
    - `progress_callback`: Function for progress updates (default: nothing)
    - `warm_start`: Previous solution for warm start (default: nothing)
    - `solver_attributes`: Solver-specific options (default: empty Dict)
    
    # Returns
    - `SolverResult` with mip_result and lp_result fields populated when pricing=true
    """
    function solve_model!(
        model::Model,
        system::ElectricitySystem;
        solver=HiGHS.Optimizer,
        time_limit::Float64=3600.0,
        mip_gap::Float64=0.01,
        output_level::Int=1,
        pricing::Bool=true,
        log_file::Union{String,Nothing}=nothing,
        progress_callback=nothing,
        warm_start::Union{SolverResult,Nothing}=nothing,
        solver_attributes::Dict{String,Any}=Dict{String,Any}()
    )
        # Implementation:
        # 1. Build SolverOptions from kwargs
        # 2. Apply warm start if provided (set start values on variables)
        # 3. If pricing=true: call compute_two_stage_lmps()
        # 4. If pricing=false: call optimize!() directly
        # 5. Populate result.mip_result and result.lp_result
        # 6. Return unified result
    end
    ```
    
    Key implementation details:
    - Auto-generate log filename using Dates.format(now(), "yyyymmdd_HHMMSS") if not provided
    - Create ./logs/ directory if it doesn't exist
    - Configure verbosity based on output_level (0=silent, 1=info, 2=debug)
    - Warm start: iterate over warm_start.variables and call set_start_value() on matching model variables
    - Two-stage: call existing compute_two_stage_lmps(), store uc_result in mip_result, sced_result in lp_result
    - Single-stage: call existing optimize!(), store in mip_result, lp_result=nothing
    - Set result.solve_status using map_to_solve_status()
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Create a small integration test verifying:
    ```julia
    # Test basic solve_model! call
    model, system = create_small_test_system()
    result = solve_model!(model, system; pricing=false, output_level=0)
    @test result.solve_status in [OPTIMAL, TIME_LIMIT]
    @test result.mip_result !== nothing
    @test result.lp_result === nothing  # No pricing
    ```
  </verify>
  <done>
    - solve_model!() function defined with all kwargs from CONTEXT.md
    - Two-stage pricing integrated via pricing kwarg
    - Log file auto-generation works
    - Warm start sets variable start values
    - Result struct has mip_result and lp_result populated
  </done>
</task>

<task type="auto">
  <name>Add unit tests for unified solve API</name>
  <files>test/unit/test_solver_interface.jl</files>
  <action>
    Create new test file test/unit/test_solver_interface.jl with comprehensive tests:
    
    Test categories:
    1. **SolveStatus enum tests:**
       - All 8 enum values are defined
       - map_to_solve_status() correctly maps each MOI status
    
    2. **solve_model!() basic tests:**
       - Function accepts all keyword arguments
       - Returns SolverResult with solve_status field
       - Works with pricing=false (single-stage)
       - Works with pricing=true (two-stage)
    
    3. **Log file generation tests:**
       - Auto-generates filename with timestamp format
       - Creates ./logs/ directory if missing
       - Respects custom log_file path
    
    4. **Warm start tests:**
       - Previous result sets start values on variables
       - Handles missing variables gracefully
    
    5. **Output level tests:**
       - output_level=0 sets MOI.Silent()
       - output_level=1,2 allow solver output
    
    Use a minimal test system (1 thermal plant, 1 period) for fast tests.
    Mock/stub the actual solve if needed for pure unit tests.
  </action>
  <verify>
    Run: `julia --project=test test/unit/test_solver_interface.jl`
    
    All tests pass with output showing:
    - Test Summary: solve_status_enum | Passed X tests
    - Test Summary: solve_model_basic | Passed X tests
    - Test Summary: log_file_generation | Passed X tests
  </verify>
  <done>
    - test/unit/test_solver_interface.jl created with 50+ tests
    - All SolveStatus values tested
    - solve_model!() API tested with all kwargs
    - Log file generation tested
    - Tests pass with `julia --project=test test/unit/test_solver_interface.jl`
  </done>
</task>

</tasks>

<verification>
1. SolveStatus enum has 8 values mapping to MOI statuses
2. solve_model!() accepts all keyword arguments from CONTEXT.md
3. Two-stage pricing works via pricing=true kwarg
4. Result struct has mip_result and lp_result fields
5. All tests pass with 50+ new tests
</verification>

<success_criteria>
- [x] SolveStatus enum defined with OPTIMAL, INFEASIBLE, TIME_LIMIT, etc.
- [x] solve_model!() function implements unified API per user decisions
- [x] Two-stage pricing integrated via pricing kwarg
- [x] Log file auto-generation works
- [x] Unit tests created and passing (50+ tests)
</success_criteria>

<output>
After completion, create `.planning/phases/03-solver-interface/03-01-SUMMARY.md`
</output>
