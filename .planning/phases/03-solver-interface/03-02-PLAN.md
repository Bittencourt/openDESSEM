---
phase: 03-solver-interface
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/solvers/solver_interface.jl
  - src/solvers/Solvers.jl
  - test/unit/test_solver_interface.jl
autonomous: true
must_haves:
  truths:
    - "User can request Gurobi/CPLEX/GLPK and get graceful fallback if not installed"
    - "HiGHS is auto-detected as default solver"
    - "Missing optional solvers produce warnings, not errors"
    - "Solver availability can be checked programmatically"
  artifacts:
    - path: "src/solvers/solver_interface.jl"
      provides: "Lazy loading with Ref availability flags"
      contains: "_try_load_"
    - path: "src/solvers/solver_interface.jl"
      provides: "solver_available() function"
      exports: ["solver_available"]
  key_links:
    - from: "get_solver_optimizer()"
      to: "lazy loading functions"
      via: "try-catch with @eval import"
      pattern: "_try_load_.*@eval"
---

<objective>
Implement lazy loading for optional solvers (Gurobi, CPLEX, GLPK) with graceful fallback and availability checking.

Purpose: Per CONTEXT.md decision: "Auto-loading with try-catch â€” attempt to load Gurobi/CPLEX/GLPK on demand, fall back gracefully." Users shouldn't need all solvers installed.

Output: Lazy loading infrastructure, solver_available() function, refined get_solver_optimizer() with graceful errors.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-solver-interface/03-CONTEXT.md
@.planning/phases/03-solver-interface/03-RESEARCH.md
@src/solvers/solver_interface.jl
@src/solvers/Solvers.jl
</context>

<tasks>

<task type="auto">
  <name>Implement lazy loading infrastructure for optional solvers</name>
  <files>src/solvers/solver_interface.jl</files>
  <action>
    Add lazy loading infrastructure at the top of solver_interface.jl (after imports):
    
    ```julia
    # ============================================================================
    # Lazy Loading Infrastructure for Optional Solvers
    # ============================================================================
    
    # Track loading attempts and availability
    const _GUROBI_LOADED = Ref{Bool}(false)
    const _GUROBI_AVAILABLE = Ref{Bool}(false)
    
    const _CPLEX_LOADED = Ref{Bool}(false)
    const _CPLEX_AVAILABLE = Ref{Bool}(false)
    
    const _GLPK_LOADED = Ref{Bool}(false)
    const _GLPK_AVAILABLE = Ref{Bool}(false)
    
    """
        _try_load_gurobi() -> Bool
    
    Attempt to load Gurobi.jl on demand.
    
    Returns true if Gurobi is available, false otherwise.
    Caches result to avoid repeated attempts.
    """
    function _try_load_gurobi()
        _GUROBI_LOADED[] && return _GUROBI_AVAILABLE[]
        
        try
            @eval import Gurobi
            _GUROBI_AVAILABLE[] = true
            @debug "Gurobi.jl loaded successfully"
        catch e
            @warn "Gurobi.jl not available" exception=(e, catch_backtrace())
            @info "Install Gurobi with: import Pkg; Pkg.add(\"Gurobi\")"
            _GUROBI_AVAILABLE[] = false
        end
        
        _GUROBI_LOADED[] = true
        return _GUROBI_AVAILABLE[]
    end
    
    """
        _try_load_cplex() -> Bool
    
    Attempt to load CPLEX.jl on demand.
    """
    function _try_load_cplex()
        _CPLEX_LOADED[] && return _CPLEX_AVAILABLE[]
        
        try
            @eval import CPLEX
            _CPLEX_AVAILABLE[] = true
            @debug "CPLEX.jl loaded successfully"
        catch e
            @warn "CPLEX.jl not available" exception=(e, catch_backtrace())
            @info "Install CPLEX with: import Pkg; Pkg.add(\"CPLEX\")"
            _CPLEX_AVAILABLE[] = false
        end
        
        _CPLEX_LOADED[] = true
        return _CPLEX_AVAILABLE[]
    end
    
    """
        _try_load_glpk() -> Bool
    
    Attempt to load GLPK.jl on demand.
    """
    function _try_load_glpk()
        _GLPK_LOADED[] && return _GLPK_AVAILABLE[]
        
        try
            @eval import GLPK
            _GLPK_AVAILABLE[] = true
            @debug "GLPK.jl loaded successfully"
        catch e
            @warn "GLPK.jl not available" exception=(e, catch_backtrace())
            @info "Install GLPK with: import Pkg; Pkg.add(\"GLPK\")"
            _GLPK_AVAILABLE[] = false
        end
        
        _GLPK_LOADED[] = true
        return _GLPK_AVAILABLE[]
    end
    ```
    
    Key points:
    - Use Ref{Bool} to track both "have we tried" and "is it available"
    - Use @eval import to dynamically load modules
    - Log warning + install hint on failure (NOT error!)
    - Cache result to avoid repeated attempts
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify lazy loading functions exist:
    ```julia
    using OpenDESSEM.Solvers
    # These should not throw errors even if Gurobi not installed
    @test _try_load_gurobi() isa Bool
    ```
  </verify>
  <done>
    - Lazy loading Ref variables defined for each optional solver
    - _try_load_*() functions defined for Gurobi, CPLEX, GLPK
    - Functions return Bool and log warnings (not errors) on failure
  </done>
</task>

<task type="auto">
  <name>Add solver_available() function and refine get_solver_optimizer()</name>
  <files>src/solvers/solver_interface.jl</files>
  <action>
    Add solver_available() function for programmatic availability checking:
    
    ```julia
    """
        solver_available(solver_type::SolverType) -> Bool
    
    Check if a solver is available without attempting to load it.
    
    For optional solvers (GUROBI, CPLEX, GLPK), attempts lazy loading.
    For HIGHS, always returns true (required dependency).
    
    # Arguments
    - `solver_type::SolverType`: Solver type to check
    
    # Returns
    - `Bool`: true if solver is available
    
    # Example
    ```julia
    if solver_available(GUROBI)
        optimizer = get_solver_optimizer(GUROBI)
    else
        @warn "Gurobi not available, using HiGHS"
        optimizer = get_solver_optimizer(HIGHS)
    end
    ```
    """
    function solver_available(solver_type::SolverType)::Bool
        if solver_type == HIGHS
            return true  # HiGHS is always available (required dependency)
        elseif solver_type == GUROBI
            return _try_load_gurobi()
        elseif solver_type == CPLEX
            return _try_load_cplex()
        elseif solver_type == GLPK
            return _try_load_glpk()
        else
            return false
        end
    end
    ```
    
    Refine get_solver_optimizer() to use lazy loading:
    
    ```julia
    function get_solver_optimizer(
        solver_type::SolverType;
        options::SolverOptions=SolverOptions(),
    )
        if solver_type == HIGHS
            return HiGHS.Optimizer
        elseif solver_type == GUROBI
            if _try_load_gurobi()
                return Gurobi.Optimizer
            else
                error("Gurobi not available. Install with: import Pkg; Pkg.add(\"Gurobi\")")
            end
        elseif solver_type == CPLEX
            if _try_load_cplex()
                return CPLEX.Optimizer
            else
                error("CPLEX not available. Install with: import Pkg; Pkg.add(\"CPLEX\")")
            end
        elseif solver_type == GLPK
            if _try_load_glpk()
                return GLPK.Optimizer
            else
                error("GLPK not available. Install with: import Pkg; Pkg.add(\"GLPK\")")
            end
        else
            error("Unsupported solver type: $solver_type")
        end
    end
    ```
    
    Update Solvers.jl to export solver_available.
  </action>
  <verify>
    Run: `julia --project=test -e 'include("test/runtests.jl")'`
    
    Verify solver_available works:
    ```julia
    using OpenDESSEM.Solvers
    @test solver_available(HIGHS) == true
    @test solver_available(GUROBI) isa Bool  # false if not installed
    ```
  </verify>
  <done>
    - solver_available() function defined and exported
    - get_solver_optimizer() uses lazy loading functions
    - HIGHS always returns true (required dependency)
    - Optional solvers trigger lazy load attempt
  </done>
</task>

<task type="auto">
  <name>Add tests for lazy loading and solver availability</name>
  <files>test/unit/test_solver_interface.jl</files>
  <action>
    Add test section to test/unit/test_solver_interface.jl:
    
    ```julia
    @testset "Lazy Loading and Solver Availability" begin
        @testset "HIGHS always available" begin
            @test solver_available(HIGHS) == true
        end
        
        @testset "Optional solvers lazy loading" begin
            # These should not throw errors regardless of installation
            @test _try_load_gurobi() isa Bool
            @test _try_load_cplex() isa Bool
            @test _try_load_glpk() isa Bool
        end
        
        @testset "solver_available function" begin
            @test solver_available(HIGHS) == true
            
            # Check optional solvers (result depends on installation)
            gurobi_avail = solver_available(GUROBI)
            @test gurobi_avail isa Bool
            
            cplex_avail = solver_available(CPLEX)
            @test cplex_avail isa Bool
            
            glpk_avail = solver_available(GLPK)
            @test glpk_avail isa Bool
        end
        
        @testset "get_solver_optimizer with lazy loading" begin
            # HIGHS should always work
            opt = get_solver_optimizer(HIGHS)
            @test opt === HiGHS.Optimizer
            
            # Optional solvers - test error if not available
            if !solver_available(GUROBI)
                @test_throws ErrorException get_solver_optimizer(GUROBI)
            end
        end
    end
    ```
  </action>
  <verify>
    Run: `julia --project=test test/unit/test_solver_interface.jl`
    
    All lazy loading tests pass showing:
    - Test Summary: Lazy Loading and Solver Availability | Passed X tests
  </verify>
  <done>
    - Tests for solver_available() added
    - Tests for lazy loading functions added
    - Tests pass with optional solvers installed or not installed
  </done>
</task>

</tasks>

<verification>
1. Lazy loading infrastructure uses Ref{Bool} for caching
2. _try_load_*() functions log warnings (not errors) on failure
3. solver_available() function works for all solver types
4. get_solver_optimizer() uses lazy loading
5. Tests cover all scenarios
</verification>

<success_criteria>
- [x] Lazy loading infrastructure with Ref caching implemented
- [x] _try_load_*() functions for Gurobi, CPLEX, GLPK
- [x] solver_available() function defined and exported
- [x] get_solver_optimizer() uses lazy loading
- [x] Tests for lazy loading pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-solver-interface/03-02-SUMMARY.md`
</output>
