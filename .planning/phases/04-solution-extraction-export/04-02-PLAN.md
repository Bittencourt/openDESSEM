---
phase: 04-solution-extraction-export
plan: 02
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/analysis/constraint_violations.jl
  - src/analysis/Analysis.jl
  - src/solvers/Solvers.jl
  - test/unit/test_constraint_violations.jl
  - test/runtests.jl
autonomous: true

must_haves:
  truths:
    - "Constraint violation report identifies violated constraints with magnitudes and types"
    - "Violations are classified by constraint type (thermal, hydro, balance, etc.)"
    - "Report can be written to file for debugging"
    - "Empty report returned when all constraints satisfied"
  artifacts:
    - path: "src/analysis/constraint_violations.jl"
      provides: "ConstraintViolation struct, ViolationReport struct, check_constraint_violations(), write_violation_report()"
      min_lines: 80
    - path: "test/unit/test_constraint_violations.jl"
      provides: "Unit tests for constraint violation detection and reporting"
      min_lines: 80
  key_links:
    - from: "src/analysis/constraint_violations.jl"
      to: "JuMP.primal_feasibility_report"
      via: "Uses JuMP's built-in feasibility checker"
      pattern: "primal_feasibility_report"
    - from: "src/analysis/Analysis.jl"
      to: "src/analysis/constraint_violations.jl"
      via: "Module includes and exports"
      pattern: "include.*constraint_violations"
---

<objective>
Create constraint violation reporting that identifies violated constraints with magnitudes and type classification, completing EXTR-05.

Purpose: After solving a model, users need to understand which constraints are violated and by how much. This is essential for debugging infeasible or near-infeasible models. Uses JuMP's `primal_feasibility_report()` rather than hand-rolling constraint iteration.

Output: New `constraint_violations.jl` module with check/report functions, integrated into the Analysis module, with comprehensive tests.
</objective>

<execution_context>
@/home/pedro/.claude/get-shit-done/workflows/execute-plan.md
@/home/pedro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-solution-extraction-export/04-RESEARCH.md
@src/analysis/Analysis.jl
@src/solvers/Solvers.jl
@test/fixtures/small_system.jl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create constraint violation reporter</name>
  <files>
    src/analysis/constraint_violations.jl
    src/analysis/Analysis.jl
    src/solvers/Solvers.jl
  </files>
  <action>
**1. Create `src/analysis/constraint_violations.jl`:**

Create a new file implementing constraint violation detection and reporting. The module uses JuMP's `primal_feasibility_report()` (do NOT hand-roll constraint iteration).

```julia
"""
    Constraint Violation Reporting

Detect, classify, and report constraint violations in solved optimization models.

Uses JuMP's `primal_feasibility_report()` to identify violations with magnitudes,
then classifies them by constraint type based on naming conventions.

# Usage
```julia
using OpenDESSEM.Analysis

report = check_constraint_violations(model; atol=1e-6)
if !isempty(report.violations)
    println("Found ", length(report.violations), " violations")
    write_violation_report(report, "violations.txt")
end
```
"""

using JuMP
using Dates
```

Define structs and functions:

**`ConstraintViolation`** struct with fields:
- `constraint_name::String` -- name of the violated constraint (from `JuMP.name(con_ref)`)
- `violation_magnitude::Float64` -- how far from feasibility
- `constraint_type::String` -- classified type: "thermal", "hydro", "balance", "network", "storage", "unknown"

**`ViolationReport`** struct with fields:
- `model_name::String` -- identifier for the model
- `timestamp::DateTime` -- when the report was generated
- `tolerance::Float64` -- the atol used for detection
- `violations::Vector{ConstraintViolation}` -- list of violations
- `total_violations::Int` -- length of violations
- `max_violation::Float64` -- maximum violation magnitude (0.0 if empty)
- `violations_by_type::Dict{String, Int}` -- count of violations per type

**`check_constraint_violations(model::Model; atol::Float64=1e-6, model_name::String="")`** function:
1. Call `JuMP.primal_feasibility_report(model; atol=atol)` -- returns `Dict{ConstraintRef, Float64}`
2. For each `(con_ref, violation_distance)` in the report:
   a. Get constraint name via `JuMP.name(con_ref)` (may be empty string)
   b. Classify the constraint type using `_classify_constraint(name)` helper
   c. Create `ConstraintViolation` with name, magnitude=`abs(violation_distance)`, type
3. Sort violations by magnitude descending (worst first)
4. Compute summary statistics: total count, max violation, violations_by_type
5. Return `ViolationReport`

**`_classify_constraint(name::String)`** helper function:
- If name contains "thermal" or starts with "thermal_" -> "thermal"
- If name contains "hydro" or "water_balance" or "storage" -> "hydro"
- If name contains "balance" or "submarket" -> "balance"
- If name contains "network" or "flow" or "line" -> "network"
- If name contains "ramp" -> "ramp"
- Otherwise -> "unknown"
- Use lowercase comparison: `lowercase(name)`

**`write_violation_report(report::ViolationReport, filepath::String)`** function:
1. Create parent directory if needed (`mkpath(dirname(filepath))`)
2. Write a human-readable text report:
```
Constraint Violation Report
===========================
Model: {model_name}
Timestamp: {timestamp}
Tolerance: {atol}

Summary
-------
Total violations: {N}
Maximum violation: {max_mag}

Violations by Type:
  thermal: {count}
  hydro: {count}
  balance: {count}
  ...

Detailed Violations (sorted by magnitude)
-----------------------------------------
1. [{type}] {constraint_name}: {magnitude}
2. [{type}] {constraint_name}: {magnitude}
...

No violations found.  (if empty)
```
3. Return the filepath

**`Base.isempty(report::ViolationReport)`** method -- returns `report.total_violations == 0`

Export: `ConstraintViolation`, `ViolationReport`, `check_constraint_violations`, `write_violation_report`

**2. Update `src/analysis/Analysis.jl`:**

Add `include("constraint_violations.jl")` after the existing `include("solution_exporter.jl")` line.

Import JuMP at the module level if not already imported (Analysis module may need `using JuMP`).

Add the new exports to the export list:
```julia
export
    # Existing exports...
    export_csv, export_json, export_database, ExportResult,
    # New constraint violation exports
    ConstraintViolation, ViolationReport, check_constraint_violations, write_violation_report
```

Note: The constraint_violations.jl file should NOT be wrapped in its own `module` like SolutionExporter is. Instead, define the functions directly at the Analysis module level (after the `using .SolutionExporter` line). This avoids needing to re-import JuMP types through a submodule. Look at how Analysis.jl currently structures imports and follow that pattern.

If Analysis.jl does use a submodule pattern for constraint_violations, then add `using .ConstraintViolations` after the include and export the public names.

**3. Verify Solvers module exports `Model` type access:**

The `check_constraint_violations` function takes a `JuMP.Model` as input. The Analysis module needs access to JuMP for this. Verify that the Analysis module imports JuMP. If not, add `using JuMP` to the Analysis module.
  </action>
  <verify>
Verify the module loads correctly:
```bash
julia --project=test -e '
using OpenDESSEM.Analysis
println("ConstraintViolation: ", isdefined(Analysis, :ConstraintViolation))
println("check_constraint_violations: ", isdefined(Analysis, :check_constraint_violations))
println("write_violation_report: ", isdefined(Analysis, :write_violation_report))
'
```
All three should print `true`. Then run the existing test suite:
```bash
julia --project=test test/runtests.jl
```
  </verify>
  <done>
- `src/analysis/constraint_violations.jl` exists with `ConstraintViolation`, `ViolationReport`, `check_constraint_violations()`, `write_violation_report()`
- `check_constraint_violations()` uses `JuMP.primal_feasibility_report()` (not hand-rolled)
- Violations are classified by type (thermal, hydro, balance, network, ramp, unknown)
- `write_violation_report()` produces human-readable text report
- Analysis module properly exports all new types and functions
- All existing tests pass
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for constraint violation reporting</name>
  <files>
    test/unit/test_constraint_violations.jl
    test/runtests.jl
  </files>
  <action>
**1. Create `test/unit/test_constraint_violations.jl`:**

Test the constraint violation reporting against both feasible and infeasible models.

```julia
using Test
using JuMP
using HiGHS
using Dates

using OpenDESSEM
using OpenDESSEM.Solvers
using OpenDESSEM.Analysis

# Include small system factory
include(joinpath(@__DIR__, "..", "fixtures", "small_system.jl"))
using .SmallSystemFactory: create_small_test_system, create_infeasible_test_system

@testset "Constraint Violations" begin

    @testset "Feasible model has no violations" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)

        # Check violations on a feasible solved model
        report = check_constraint_violations(model; atol=1e-6)

        @test report isa ViolationReport
        @test isempty(report)
        @test report.total_violations == 0
        @test report.max_violation == 0.0
        @test isempty(report.violations)
    end

    @testset "ViolationReport struct fields" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)

        report = check_constraint_violations(model; atol=1e-6, model_name="test_model")

        @test report.model_name == "test_model"
        @test report.tolerance == 1e-6
        @test report.timestamp isa DateTime
        @test report.violations isa Vector{ConstraintViolation}
        @test report.violations_by_type isa Dict{String, Int}
    end

    @testset "ConstraintViolation struct" begin
        cv = ConstraintViolation(
            constraint_name="test_constraint",
            violation_magnitude=0.5,
            constraint_type="thermal"
        )
        @test cv.constraint_name == "test_constraint"
        @test cv.violation_magnitude == 0.5
        @test cv.constraint_type == "thermal"
    end

    @testset "Custom tolerance changes detection" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)

        # Very tight tolerance might catch numerical noise
        report_tight = check_constraint_violations(model; atol=1e-15)
        # Loose tolerance should find fewer or no violations
        report_loose = check_constraint_violations(model; atol=1.0)

        @test report_loose.total_violations <= report_tight.total_violations
    end

    @testset "write_violation_report creates file" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)
        report = check_constraint_violations(model; model_name="write_test")

        mktempdir() do tmpdir
            filepath = joinpath(tmpdir, "violations.txt")
            returned_path = write_violation_report(report, filepath)

            @test isfile(filepath)
            @test returned_path == filepath

            content = read(filepath, String)
            @test occursin("Constraint Violation Report", content)
            @test occursin("write_test", content)
            @test occursin("Tolerance", content)
        end
    end

    @testset "write_violation_report with no violations" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)
        report = check_constraint_violations(model)

        mktempdir() do tmpdir
            filepath = joinpath(tmpdir, "no_violations.txt")
            write_violation_report(report, filepath)

            content = read(filepath, String)
            @test occursin("0", content)  # Total violations: 0
        end
    end

    @testset "isempty works on ViolationReport" begin
        model, system = create_small_test_system()
        result = solve_model!(model, system; pricing=false)

        report = check_constraint_violations(model)
        @test isempty(report) == (report.total_violations == 0)
    end

    @testset "Violations sorted by magnitude descending" begin
        # Create a report with multiple violations manually to test sorting
        violations = [
            ConstraintViolation(
                constraint_name="small",
                violation_magnitude=0.001,
                constraint_type="thermal"
            ),
            ConstraintViolation(
                constraint_name="large",
                violation_magnitude=1.0,
                constraint_type="balance"
            ),
            ConstraintViolation(
                constraint_name="medium",
                violation_magnitude=0.1,
                constraint_type="hydro"
            ),
        ]

        report = ViolationReport(
            model_name="test",
            timestamp=now(),
            tolerance=1e-6,
            violations=sort(violations; by=v->v.violation_magnitude, rev=true),
            total_violations=3,
            max_violation=1.0,
            violations_by_type=Dict("thermal"=>1, "balance"=>1, "hydro"=>1),
        )

        @test report.violations[1].constraint_name == "large"
        @test report.violations[2].constraint_name == "medium"
        @test report.violations[3].constraint_name == "small"
    end
end
```

**2. Update `test/runtests.jl`:**

Add `include("unit/test_constraint_violations.jl")` to the test includes. Place it after the other unit test includes. If Plan 01 has already added `test_solution_extraction.jl` and `test_solution_exporter.jl`, place this after those.

Note: Since Plan 01 and Plan 02 both modify `test/runtests.jl`, be careful about merge conflicts. Plan 02 should READ the current runtests.jl before editing and add its include in a non-conflicting location. Add a blank line before the new include for clarity.
  </action>
  <verify>
Run the full test suite:
```bash
julia --project=test test/runtests.jl
```

Specifically verify:
- "Feasible model has no violations" test passes (feasible model returns empty report)
- "write_violation_report creates file" test passes (report is written to disk)
- "ViolationReport struct fields" test passes (all fields have correct types)
- Total test count increases
  </verify>
  <done>
- `test/unit/test_constraint_violations.jl` exists with tests for feasible model (no violations), struct fields, report file creation, tolerance sensitivity, and violation sorting
- Test file is included in `test/runtests.jl`
- All tests pass including the new constraint violation tests
- EXTR-05 (constraint violation reporting with magnitude and type) is verified by tests
  </done>
</task>

</tasks>

<verification>
Run the full test suite:
```bash
julia --project=test test/runtests.jl
```

Verify:
1. `check_constraint_violations()` on a feasible solved model returns an empty ViolationReport
2. `ViolationReport` has correct types for all fields
3. `write_violation_report()` creates a readable text file with model name, tolerance, and violation details
4. Constraint types are classified correctly (thermal, hydro, balance, etc.)
5. No regressions in existing tests
</verification>

<success_criteria>
- EXTR-05: Constraint violation report identifies violated constraints with magnitudes and types -- verified by check_constraint_violations returning classified ConstraintViolation objects and write_violation_report producing human-readable output
- ConstraintViolation, ViolationReport types are exported from OpenDESSEM.Analysis
- check_constraint_violations and write_violation_report are exported from OpenDESSEM.Analysis
- Feasible models produce empty reports, violations are sorted by magnitude
</success_criteria>

<output>
After completion, create `.planning/phases/04-solution-extraction-export/04-02-SUMMARY.md`
</output>
