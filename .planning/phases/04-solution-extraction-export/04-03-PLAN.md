---
phase: 04-solution-extraction-export
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/solvers/solution_extraction.jl
  - src/solvers/Solvers.jl
  - test/unit/test_solution_extraction.jl
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Nodal LMPs can be extracted per bus per time period when network data is available"
    - "get_nodal_lmp_dataframe() returns bus-level prices as a DataFrame"
    - "Function works with solved results and network data from the system"
    - "Graceful degradation when PowerModels is not available"
  artifacts:
    - path: "src/solvers/solution_extraction.jl"
      provides: "get_nodal_lmp_dataframe() function for bus-level LMP extraction"
      exports: ["get_nodal_lmp_dataframe"]
    - path: "test/unit/test_solution_extraction.jl"
      provides: "Tests for nodal LMP extraction"
  key_links:
    - from: "src/solvers/solution_extraction.jl"
      to: "src/integration/Integration.jl"
      via: "Calls solve_dc_opf_nodal_lmps() for DC-OPF solve"
      pattern: "solve_dc_opf_nodal_lmps"
    - from: "src/solvers/solution_extraction.jl"
      to: "src/integration/powermodels_adapter.jl"
      via: "Uses convert_to_powermodel() for data conversion"
      pattern: "convert_to_powermodel"
---

<objective>
Add `get_nodal_lmp_dataframe()` function to extract bus-level locational marginal prices (nodal LMPs/PLDs) from PowerModels DC-OPF, addressing the gap where PLDs were only available at submarket level.

Purpose: Users need bus-level nodal pricing (PLDs) calculated as duals of each bus energy balance constraint, not just submarket-level aggregate prices. The existing `solve_dc_opf_nodal_lmps()` function provides this capability but is not exposed through the extraction API.

Output: New `get_nodal_lmp_dataframe()` function that internally calls the existing DC-OPF solver and returns bus-level prices as a DataFrame.

**Approach rationale:** Near-term solution that uses the existing standalone `solve_dc_opf_nodal_lmps()` function rather than full PowerModels integration into the main solve pipeline. This keeps the current submarket PLD structure intact while adding nodal pricing capability. Full integration (creating bus_balance constraints in the main model) would be a larger architectural change deferred to a future version.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-solution-extraction-export/04-UAT.md
@src/solvers/solution_extraction.jl
@src/integration/Integration.jl
@src/integration/powermodels_adapter.jl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create get_nodal_lmp_dataframe() function</name>
  <files>
    src/solvers/solution_extraction.jl
    src/solvers/Solvers.jl
  </files>
  <action>
Add a new `get_nodal_lmp_dataframe()` function to `src/solvers/solution_extraction.jl` that extracts bus-level nodal LMPs using PowerModels DC-OPF.

**Implementation requirements:**

1. **Function signature:**
```julia
"""
    get_nodal_lmp_dataframe(
        result::SolverResult,
        system::ElectricitySystem;
        time_periods::Union{UnitRange{Int}, Nothing}=nothing,
        solver_factory=nothing
    ) -> DataFrame

Extract nodal locational marginal prices (LMPs) per bus using PowerModels DC-OPF.

Calculates bus-level prices by:
1. Converting system network data to PowerModels format
2. Solving DC-OPF with the dispatch from the result
3. Extracting duals of bus balance constraints (nodal LMPs)

# Arguments
- `result::SolverResult`: Solved result with dispatch values
- `system::ElectricitySystem`: System with buses, lines, and generators
- `time_periods::Union{UnitRange{Int}, Nothing}`: Time periods to extract (default: all available)
- `solver_factory`: Optimizer factory for DC-OPF (default: HiGHS.Optimizer)

# Returns
- `DataFrame` with columns:
  - `bus_id`: Bus identifier
  - `bus_name`: Bus name (if available)
  - `period`: Time period index
  - `lmp`: Nodal LMP value (R$/MWh)

# Example
```julia
# After solving the main model
result = solve_model!(model, system)
if result.solve_status == OPTIMAL
    # Get nodal LMPs per bus
    nodal_lmps = get_nodal_lmp_dataframe(result, system)
    println(first(nodal_lmps, 5))
end
```

# Notes
- Requires PowerModels.jl and a solver (HiGHS recommended)
- Returns empty DataFrame if PowerModels not available or network data missing
- LMPs are calculated independently for each time period
- Uses DC power flow approximation (linearized)
"""
function get_nodal_lmp_dataframe(
    result::SolverResult,
    system::ElectricitySystem;
    time_periods::Union{UnitRange{Int}, Nothing}=nothing,
    solver_factory=nothing
)
```

2. **Implementation logic:**

a. **Early returns for missing data:**
   - If `system.buses` is empty, return empty DataFrame with correct schema
   - If PowerModels is not available (check with try/catch), return empty DataFrame with warning

b. **Determine time periods:**
   - If `time_periods` is nothing, infer from `result.variables[:thermal_generation]` keys
   - Extract the range of periods from the dispatch data

c. **Default solver:**
   - If `solver_factory` is nothing, use `HiGHS.Optimizer`
   - Wrap in try/catch in case HiGHS not available

d. **For each time period:**
   - Build PowerModels data dict with:
     - Network topology (buses, lines from system)
     - Generator dispatch (fixed pg values from result)
     - Load at each bus (from system.loads)
   - Call `solve_dc_opf_nodal_lmps(pm_data, solver_factory)` from Integration module
   - Extract `result["nodal_lmps"]` dict mapping bus_id -> LMP
   - Add rows to DataFrame

e. **Return DataFrame with columns:**
   - `bus_id::String`
   - `bus_name::String` (look up from system.buses)
   - `period::Int`
   - `lmp::Float64` (R$/MWh, already in correct units from solve_dc_opf_nodal_lmps)

3. **Helper function for building PowerModels data:**

Create a helper `_build_nodal_opf_data()` that constructs PowerModels-compatible data dict:
```julia
"""
    _build_nodal_opf_data(
        system::ElectricitySystem,
        result::SolverResult,
        period::Int
    ) -> Dict

Build PowerModels data dict for a single time period with fixed generation.
"""
function _build_nodal_opf_data(
    system::ElectricitySystem,
    result::SolverResult,
    period::Int
)
```

This helper should:
- Use `convert_to_powermodel()` from Integration module for network topology
- Override generator `pg` values with dispatch from `result`
- Include bus loads from `system.loads` for the period
- Set `gen["cost"]` to zeros (dispatch is fixed, cost doesn't matter for LMP extraction)

4. **Update exports in `src/solvers/Solvers.jl`:**

Add `get_nodal_lmp_dataframe` to the export list after `get_pld_dataframe`.

5. **Integration with existing module:**

The function needs to import from `Integration` module:
```julia
# At the top of solution_extraction.jl, ensure Integration is accessible
# The function will use:
# - Integration.solve_dc_opf_nodal_lmps
# - Integration.convert_to_powermodel (or via Entities conversion)
```

Since solution_extraction.jl is part of the Solvers module and Integration is a sibling module, use:
```julia
using ..Integration: solve_dc_opf_nodal_lmps, convert_to_powermodel
```
Or access via the module path when calling.

**Important constraints:**
- DO NOT modify `extract_dual_values!()` - that remains for submarket-level PLDs
- DO NOT modify NetworkPowerModelsConstraint - full integration is deferred
- This function is standalone and optional - works when PowerModels available
- Graceful degradation: return empty DataFrame (not error) if dependencies missing
  </action>
  <verify>
Verify the function is exported and accessible:
```bash
julia --project=test -e '
using OpenDESSEM.Solvers
println("get_nodal_lmp_dataframe exported: ", isdefined(Solvers, :get_nodal_lmp_dataframe))
'
```

Should print `true`. Then verify the function runs without error on a system without buses (returns empty DataFrame):
```bash
julia --project=test -e '
using OpenDESSEM
using OpenDESSEM.Solvers
using OpenDESSEM.Entities

# Create empty system
system = ElectricitySystem()
result = SolverResult()
df = get_nodal_lmp_dataframe(result, system)
println("Empty system returns DataFrame with columns: ", names(df))
println("Row count: ", nrow(df))
'
```

Should return DataFrame with columns `[:bus_id, :bus_name, :period, :lmp]` and 0 rows.
  </verify>
  <done>
- `get_nodal_lmp_dataframe()` function exists in `src/solvers/solution_extraction.jl`
- Function exported from Solvers module
- Returns DataFrame with columns: bus_id, bus_name, period, lmp
- Returns empty DataFrame gracefully when PowerModels not available or no network data
- Function has comprehensive docstring with examples
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for nodal LMP extraction</name>
  <files>
    test/unit/test_solution_extraction.jl
  </files>
  <action>
Add test cases to `test/unit/test_solution_extraction.jl` for the new `get_nodal_lmp_dataframe()` function.

**Tests to add:**

1. **Test: Empty system returns empty DataFrame with correct schema**
```julia
@testset "get_nodal_lmp_dataframe - empty system" begin
    system = ElectricitySystem()
    result = SolverResult()
    
    df = get_nodal_lmp_dataframe(result, system)
    
    @test df isa DataFrame
    @test names(df) == ["bus_id", "bus_name", "period", "lmp"]
    @test nrow(df) == 0
end
```

2. **Test: System without network data returns empty DataFrame**
```julia
@testset "get_nodal_lmp_dataframe - no network data" begin
    # Create system with thermal plants but no buses
    thermal = ConventionalThermal(;
        id="T001", name="Test", bus_id="B001", submarket_id="SE",
        fuel_type=NATURAL_GAS, capacity_mw=100.0, min_generation_mw=10.0,
        max_generation_mw=100.0, ramp_up_mw_per_min=10.0, ramp_down_mw_per_min=10.0,
        min_up_time_hours=1, min_down_time_hours=1,
        fuel_cost_rsj_per_mwh=100.0, startup_cost_rs=1000.0, shutdown_cost_rs=500.0
    )
    system = ElectricitySystem(; thermal_plants=[thermal])
    result = SolverResult()
    
    df = get_nodal_lmp_dataframe(result, system)
    
    @test nrow(df) == 0  # No buses in system
end
```

3. **Test: Function handles missing PowerModels gracefully**
```julia
@testset "get_nodal_lmp_dataframe - PowerModels unavailable" begin
    # This test verifies graceful degradation
    # Even if PowerModels isn't loaded, function should not error
    system = ElectricitySystem()
    result = SolverResult()
    
    # Should return empty DataFrame, not throw error
    df = get_nodal_lmp_dataframe(result, system)
    @test df isa DataFrame
end
```

4. **Test: Function with valid system and result (if PowerModels available)**
```julia
@testset "get_nodal_lmp_dataframe - with network data" begin
    # This test requires PowerModels to be available
    # Use try/catch to skip if not installed
    
    try
        using PowerModels
        using HiGHS
        
        # Create a small system with buses and lines
        bus1 = Bus(; id="B1", name="Bus 1", voltage_kv=138.0, base_kv=138.0,
                   dc_bus=false, is_reference=true, area_id="A1", zone_id="Z1")
        bus2 = Bus(; id="B2", name="Bus 2", voltage_kv=138.0, base_kv=138.0,
                   dc_bus=false, is_reference=false, area_id="A1", zone_id="Z1")
        line = ACLine(; id="L1", name="Line 1-2", from_bus_id="B1", to_bus_id="B2",
                      resistance_ohm=1.0, reactance_ohm=10.0, susceptance_siemen=0.0,
                      max_flow_mw=100.0, min_flow_mw=0.0, length_km=50.0)
        load = NetworkLoad(; id="LD1", bus_id="B2", name="Load at B2",
                           profile_mw=[50.0, 60.0, 70.0])
        
        system = ElectricitySystem(;
            buses=[bus1, bus2],
            ac_lines=[line],
            network_loads=[load]
        )
        
        # Create a mock result with dispatch values
        result = SolverResult()
        result.variables[:thermal_generation] = Dict(("T001", 1) => 50.0)
        result.has_values = true
        
        # Get nodal LMPs
        df = get_nodal_lmp_dataframe(result, system; time_periods=1:1)
        
        @test df isa DataFrame
        @test "bus_id" in names(df)
        @test "lmp" in names(df)
        # If PowerModels worked, should have rows
        # (exact values depend on solver convergence)
        
    catch e
        @warn "PowerModels test skipped: $e"
        @test_skip false  # Skip test if PowerModels not available
    end
end
```

5. **Test: DataFrame sorting and structure**
```julia
@testset "get_nodal_lmp_dataframe - output structure" begin
    # Test that output DataFrame has correct types
    df = DataFrame(;
        bus_id=String[], bus_name=String[], period=Int[], lmp=Float64[]
    )
    
    @test eltype(df.bus_id) == String
    @test eltype(df.bus_name) == String
    @test eltype(df.period) == Int
    @test eltype(df.lmp) == Float64
end
```

**Placement:** Add these tests at the end of the existing `test_solution_extraction.jl` file, in a new `@testset "Nodal LMP Extraction"` block.

**Note:** Tests that require PowerModels should use `@test_skip` or try/catch to handle cases where PowerModels is not installed. The key is verifying the function interface and graceful degradation, not the exact LMP values.
  </action>
  <verify>
Run the full test suite:
```bash
julia --project=test test/runtests.jl
```

Verify:
1. New tests are included and pass (or skip gracefully if PowerModels unavailable)
2. No regressions in existing tests
3. Test count increases
  </verify>
  <done>
- Tests for `get_nodal_lmp_dataframe()` added to `test_solution_extraction.jl`
- Tests cover: empty system, missing network data, PowerModels unavailability, valid system with network
- All tests pass (or skip gracefully)
- No regressions in existing test suite
  </done>
</task>

</tasks>

<verification>
**Functional verification:**

1. **Function exists and is exported:**
```bash
julia --project=test -e '
using OpenDESSEM.Solvers
@show isdefined(Solvers, :get_nodal_lmp_dataframe)
'
```

2. **Empty system handling:**
```bash
julia --project=test -e '
using OpenDESSEM
using OpenDESSEM.Solvers
using OpenDESSEM.Entities

system = ElectricitySystem()
result = SolverResult()
df = get_nodal_lmp_dataframe(result, system)
@show names(df)
@show nrow(df)
'
```
Expected: `names(df) = ["bus_id", "bus_name", "period", "lmp"]`, `nrow(df) = 0`

3. **Full test suite:**
```bash
julia --project=test test/runtests.jl
```
Expected: All tests pass, including new nodal LMP tests

4. **Documentation check:**
```bash
julia --project=test -e '
using OpenDESSEM.Solvers
println(docstring(get_nodal_lmp_dataframe))
'
```
Expected: Prints comprehensive docstring with examples
</verification>

<success_criteria>
- **Gap closed:** PLD marginal prices can now be extracted from bus-level nodal marginal pricing (not just submarket aggregates)
- **Functionality:** `get_nodal_lmp_dataframe(result, system)` returns DataFrame with bus_id, bus_name, period, lmp columns
- **Graceful degradation:** Function returns empty DataFrame (not error) when PowerModels unavailable or no network data
- **Tests:** Unit tests verify function behavior for various input conditions
- **Non-breaking:** Existing submarket-level `get_pld_dataframe()` remains unchanged
- **Documentation:** Function has docstring with usage examples
</success_criteria>

<output>
After completion, create `.planning/phases/04-solution-extraction-export/04-03-SUMMARY.md`
</output>
