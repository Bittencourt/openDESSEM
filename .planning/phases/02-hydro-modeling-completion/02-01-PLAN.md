---
phase: 02-hydro-modeling-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/utils/cascade_topology.jl
  - src/core/electricity_system.jl
  - src/OpenDESSEM.jl
autonomous: true

must_haves:
  truths:
    - "Cascade topology builds correctly from hydro plant downstream_plant_id references"
    - "Circular cascade dependencies are detected at ElectricitySystem construction with full cycle path"
    - "Plant depths from headwaters are computed correctly"
    - "Unknown downstream references are handled gracefully with warnings"
  artifacts:
    - path: "src/utils/cascade_topology.jl"
      provides: "CascadeTopology struct and build_cascade_topology()"
      min_lines: 100
      exports: ["CascadeTopology", "build_cascade_topology", "find_headwaters", "find_terminal_plants"]
    - path: "src/core/electricity_system.jl"
      provides: "Cycle detection in constructor"
      contains: "build_cascade_topology"
  key_links:
    - from: "src/utils/cascade_topology.jl"
      to: "src/core/electricity_system.jl"
      via: "import and call build_cascade_topology()"
      pattern: "using.*CascadeTopology|build_cascade_topology"
---

<objective>
Create cascade topology utility with cycle detection and integrate into ElectricitySystem for fail-fast validation.

Purpose: Enable realistic multi-reservoir hydro modeling by building DAG topology from downstream_plant_id references, detecting circular dependencies at system construction time, and computing plant depths for ordered constraint building.

Output: New cascade_topology.jl module with CascadeTopology struct and build_cascade_topology() function, integrated into ElectricitySystem constructor for cycle detection.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-hydro-modeling-completion/02-CONTEXT.md
@.planning/phases/02-hydro-modeling-completion/02-RESEARCH.md
@src/entities/hydro.jl
@src/core/electricity_system.jl
</context>

<tasks>

<task type="auto">
  <name>Create cascade topology utility module</name>
  <files>src/utils/cascade_topology.jl, src/OpenDESSEM.jl</files>
  <action>
Create new file `src/utils/cascade_topology.jl` with:

1. **CascadeTopology struct** holding:
   - `upstream_map::Dict{String,Vector{Tuple{String,Float64}}}` - downstream_id => [(upstream_id, delay_hours)]
   - `depths::Dict{String,Int}` - plant_id => depth from headwater (headwaters = 0)
   - `topological_order::Vector{String}` - plants ordered upstream-first
   - `headwaters::Vector{String}` - plants with no upstream
   - `terminals::Vector{String}` - plants with no downstream

2. **build_cascade_topology(hydro_plants::Vector{<:HydroPlant}) -> CascadeTopology** function:
   - Build plant_dict: id => plant for lookup
   - Initialize upstream_map with empty vectors for all plants
   - For each plant with downstream_plant_id:
     - If downstream exists in plant_dict: add (plant.id, plant.water_travel_time_hours) to upstream_map[downstream_id]
     - If downstream NOT in plant_dict: log warning "Unknown downstream reference", treat as terminal (do NOT throw)
   - Detect cycles via DFS with recursion stack:
     - Track visited set and rec_stack set
     - On cycle detection, throw ArgumentError with full path: "Circular cascade detected: H001 → H002 → H003 → H001"
   - Compute depths via BFS from headwaters (plants with empty upstream_map entries)
   - Build topological_order (BFS traversal order)

3. **Helper functions:**
   - `find_headwaters(topology::CascadeTopology) -> Vector{String}`
   - `find_terminal_plants(topology::CascadeTopology) -> Vector{String}`
   - `get_upstream_plants(topology::CascadeTopology, plant_id::String) -> Vector{Tuple{String,Float64}}`

4. **Add include to src/OpenDESSEM.jl:**
   - Add `include("utils/cascade_topology.jl")` after existing includes
   - Export CascadeTopology, build_cascade_topology

Follow existing patterns from src/entities/validation.jl for docstring style.
Use Dict{String, ...} for all mappings since plant IDs are strings.
</action>
  <verify>
Commands:
```bash
# Check file exists and has required content
test -f src/utils/cascade_topology.jl && echo "File created"

# Check for key functions
grep -q "struct CascadeTopology" src/utils/cascade_topology.jl && echo "CascadeTopology struct found"
grep -q "function build_cascade_topology" src/utils/cascade_topology.jl && echo "build_cascade_topology found"
grep -q "Circular cascade detected" src/utils/cascade_topology.jl && echo "Cycle detection error found"

# Check OpenDESSEM.jl includes the new file
grep -q "cascade_topology.jl" src/OpenDESSEM.jl && echo "Include added to OpenDESSEM.jl"

# Run existing tests to ensure no regressions
julia --project=test -e 'using Test; include("test/runtests.jl")'
```
</verify>
  <done>CascadeTopology struct defined, build_cascade_topology() implements DFS cycle detection with full path error messages, BFS depth computation, and helper functions. Module included and exported in OpenDESSEM.jl.</done>
</task>

<task type="auto">
  <name>Add cascade validation to ElectricitySystem constructor</name>
  <files>src/core/electricity_system.jl</files>
  <action>
Modify `src/core/electricity_system.jl` to add cascade cycle detection:

1. **Add import** at top of file (after existing using statements):
   ```julia
   using ..CascadeTopology: build_cascade_topology
   ```
   Or if that doesn't work due to module loading order, add:
   ```julia
   import ..build_cascade_topology
   ```

2. **In ElectricitySystem inner constructor** (after existing validation):
   - Find the constructor that takes all entities as keyword arguments
   - After referential integrity validation, add cascade validation:
   ```julia
   # Validate cascade topology (detect cycles)
   if !isempty(hydro_plants)
       try
           cascade_topology = build_cascade_topology(hydro_plants)
           # Store topology for later use by constraint builders (optional)
       catch e
           if e isa ArgumentError
               rethrow(e)  # Re-throw cycle detection errors
           else
               rethrow(e)
           end
       end
   end
   ```

3. **Do NOT store the topology in ElectricitySystem** - just validate. Constraint builders will call build_cascade_topology() when needed.

The validation should happen BEFORE the `new(...)` call that creates the struct instance.

Reference: Research.md states "At ElectricitySystem construction time (fail fast)" and CONTEXT.md confirms "Throw ArgumentError immediately" for cycles.
</action>
  <verify>
Commands:
```bash
# Check for cascade validation in constructor
grep -q "build_cascade_topology" src/core/electricity_system.jl && echo "Cascade validation added"

# Check that it's in the constructor (after the struct definition)
grep -A 50 "function ElectricitySystem" src/core/electricity_system.jl | grep -q "build_cascade_topology" && echo "Validation in constructor"

# Run tests
julia --project=test -e 'using Test; include("test/runtests.jl")'
```
</verify>
  <done>ElectricitySystem constructor validates cascade topology by calling build_cascade_topology(), throws ArgumentError with full cycle path if circular dependencies detected.</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. Create a test case with circular cascade (H001 → H002 → H001) - should throw ArgumentError
2. Create a test case with valid cascade (H001 → H002 → H003) - should succeed
3. Create a test case with unknown downstream reference - should warn but succeed
4. All existing tests still pass (1100+ tests)
</verification>

<success_criteria>
- CascadeTopology struct exists with upstream_map, depths, topological_order fields
- build_cascade_topology() detects cycles via DFS with full path error message
- Plant depths computed correctly from headwaters (BFS)
- Unknown downstream references log warning, don't throw error
- ElectricitySystem constructor validates cascade and throws on cycles
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-hydro-modeling-completion/02-01-SUMMARY.md`
</output>
