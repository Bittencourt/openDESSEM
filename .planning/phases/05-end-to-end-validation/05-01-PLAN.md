---
phase: 05-end-to-end-validation
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/validation/validation_types.jl
  - src/validation/reference_loader.jl
  - test/validation/test_validation_types.jl
  - test/validation/test_reference_loader.jl
autonomous: true

must_haves:
  truths:
    - "ValidationResult struct holds per-metric pass/fail, detailed comparisons, exit code, and timestamp"
    - "MetricComparison struct represents individual metric results with expected/actual values and configurable tolerance"
    - "Reference CSV files load into DataFrames with correct column schemas for cost, PLD, thermal dispatch, hydro dispatch, and hydro storage"
    - "Reference JSON files load into equivalent DataFrames when format=:json is specified"
    - "Missing reference files return nothing (not error) with @warn logging"
  artifacts:
    - path: "src/validation/validation_types.jl"
      provides: "ValidationResult, MetricComparison, PLDComparison, DispatchComparison structs"
      contains: "struct ValidationResult"
    - path: "src/validation/reference_loader.jl"
      provides: "load_reference_cost, load_reference_pld, load_reference_thermal_dispatch, load_reference_hydro_dispatch, load_reference_hydro_storage"
      contains: "function load_reference_cost"
    - path: "test/validation/test_validation_types.jl"
      provides: "Unit tests for all validation types"
      min_lines: 50
    - path: "test/validation/test_reference_loader.jl"
      provides: "Unit tests for all reference loaders"
      min_lines: 80
  key_links:
    - from: "src/validation/reference_loader.jl"
      to: "CSV.jl / JSON3.jl"
      via: "CSV.read and JSON3.read for file loading"
      pattern: "CSV\\.read.*DataFrame"
    - from: "src/validation/validation_types.jl"
      to: "src/validation/reference_loader.jl"
      via: "Types used by loaders and downstream comparators"
      pattern: "MetricComparison|ValidationResult"
---

<objective>
Create the foundational data types and reference data loaders for Phase 5 validation.

Purpose: These types and loaders are the substrate that comparators (Plan 02) and reporters (Plan 03) build upon. Without well-defined structs and reliable data loading, nothing downstream works.

Output:
- `ValidationResult` struct with pass/fail per metric, exit code, and full introspection
- `MetricComparison` struct for individual metric results (cost, PLD, dispatch)
- `PLDComparison` and `DispatchComparison` for detailed per-item results
- Reference data loaders for all 5 CSV schemas (cost, PLD, thermal dispatch, hydro dispatch, hydro storage)
- Support for both CSV and JSON reference data formats
- `validation_exit_code()` function for CI integration
</objective>

<execution_context>
@/home/pedro/.claude/get-shit-done/workflows/execute-plan.md
@/home/pedro/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-end-to-end-validation/05-CONTEXT.md
@.planning/phases/05-end-to-end-validation/05-RESEARCH.md
@src/analysis/constraint_violations.jl (pattern: ViolationReport accumulate-then-report struct)
@src/solvers/solution_extraction.jl (pattern: SolverResult struct layout)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create validation types with TDD</name>
  <files>
    src/validation/validation_types.jl
    test/validation/test_validation_types.jl
  </files>
  <action>
**RED phase: Write tests first in `test/validation/test_validation_types.jl`.**

Create test file that imports the validation types and tests:

1. **MetricComparison struct** (using `Base.@kwdef`):
   - Fields: `metric_type::Symbol` (:cost, :pld, :dispatch), `status::Symbol` (:passed, :failed, :skipped), `expected::Float64`, `actual::Float64`, `tolerance::Float64`, `relative_diff::Float64`, `reason::String` (for skipped), `pass_rate::Float64` (for PLD), `threshold::Float64` (for PLD), `total_comparisons::Int`, `passed_comparisons::Int`, `details::Vector{Any}` (holds PLDComparison or DispatchComparison items)
   - Test construction with all fields
   - Test default values (reason="", pass_rate=0.0, etc.)

2. **PLDComparison struct** (using `Base.@kwdef`):
   - Fields: `submarket::String`, `period::Int`, `expected::Float64`, `actual::Float64`, `passed::Bool`
   - Test construction and field access

3. **DispatchComparison struct** (using `Base.@kwdef`):
   - Fields: `plant_id::String`, `period::Int`, `expected::Float64`, `actual::Float64`, `passed::Bool`, `plant_type::Symbol` (:thermal, :hydro)
   - Test construction

4. **ValidationResult struct** (using `Base.@kwdef`):
   - Fields: `passed::Bool`, `cost_passed::Bool`, `pld_passed::Bool`, `dispatch_passed::Bool`, `comparisons::Vector{MetricComparison}`, `cost_comparison::Union{MetricComparison, Nothing}`, `pld_comparison::Union{MetricComparison, Nothing}`, `dispatch_comparisons::Vector{MetricComparison}`, `reference_dir::String`, `timestamp::DateTime`, `exit_code::Int`
   - Test construction with all passed
   - Test construction with mixed pass/fail

5. **`validation_exit_code()` function**:
   - Takes ValidationResult, returns Int exit code
   - Per CONTEXT.md: 0 = all pass, 1 = cost failed, 2 = PLD failed, 3 = dispatch failed
   - When multiple fail, return highest-priority (cost=1 wins)
   - Test: all pass => 0
   - Test: cost fail only => 1
   - Test: PLD fail only => 2
   - Test: dispatch fail only => 3
   - Test: cost + PLD fail => 1 (cost takes priority as first failure)

**GREEN phase: Implement in `src/validation/validation_types.jl`.**

Implement all structs with `Base.@kwdef` and sensible defaults. Implement `validation_exit_code()`.

Note: Do NOT create the `Validation.jl` module file yet - that happens in Plan 03 when wiring everything together. For now, the types file is standalone and tests include it directly.

**REFACTOR:** Ensure docstrings follow project conventions (arguments, example, fields documented).
  </action>
  <verify>
Run: `julia --project=test -e 'include("test/validation/test_validation_types.jl")'`
All tests pass. At least 30 @test assertions covering all struct construction and validation_exit_code() cases.
  </verify>
  <done>
All validation type structs (MetricComparison, PLDComparison, DispatchComparison, ValidationResult) construct correctly with keyword arguments. validation_exit_code() returns correct exit codes per CONTEXT.md specification (0/1/2/3). All tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create reference data loaders with TDD</name>
  <files>
    src/validation/reference_loader.jl
    test/validation/test_reference_loader.jl
  </files>
  <action>
**RED phase: Write tests first in `test/validation/test_reference_loader.jl`.**

Create test file that tests reference data loading functions. Use `mktempdir()` to create temporary reference directories with small test CSV and JSON files.

1. **`load_reference_cost(reference_dir; format=:csv)`**:
   - CSV schema: single column `total_cost_rs` with one value
   - Test: loads valid CSV, returns Float64
   - Test: missing file returns nothing (no error)
   - Test: JSON format loads correctly (schema: `{"total_cost_rs": 12345.67}`)

2. **`load_reference_pld(reference_dir; format=:csv)`**:
   - CSV schema: `period,submarket,pld_rs_per_mwh`
   - Test: loads valid CSV, returns DataFrame with correct columns
   - Test: data has correct types (Int, String, Float64)
   - Test: missing file returns nothing
   - Test: JSON format loads correctly

3. **`load_reference_thermal_dispatch(reference_dir; format=:csv)`**:
   - CSV schema: `period,plant_id,generation_mw`
   - Test: loads valid CSV, returns DataFrame
   - Test: missing file returns nothing

4. **`load_reference_hydro_dispatch(reference_dir; format=:csv)`**:
   - CSV schema: `period,plant_id,generation_mw`
   - Test: loads valid CSV, returns DataFrame
   - Test: missing file returns nothing

5. **`load_reference_hydro_storage(reference_dir; format=:csv)`**:
   - CSV schema: `period,plant_id,storage_hm3`
   - Test: loads valid CSV, returns DataFrame
   - Test: missing file returns nothing

**GREEN phase: Implement in `src/validation/reference_loader.jl`.**

Each loader function:
- Takes `reference_dir::String` and `format::Symbol = :csv` keyword argument
- Constructs filepath from reference_dir + expected filename
- If file missing: `@warn` and return `nothing`
- If CSV: `CSV.read(filepath, DataFrame)`
- If JSON: `JSON3.read(read(filepath, String))` then convert to DataFrame
- `load_reference_cost` returns `Union{Float64, Nothing}` (extracts single value from CSV/JSON)
- All others return `Union{DataFrame, Nothing}`

File naming convention for CSV: `total_cost.csv`, `pld_by_submarket.csv`, `thermal_dispatch.csv`, `hydro_dispatch.csv`, `hydro_storage.csv`
File naming convention for JSON: same names with `.json` extension

**REFACTOR:** Add comprehensive docstrings with field schemas documented.
  </action>
  <verify>
Run: `julia --project=test -e 'include("test/validation/test_reference_loader.jl")'`
All tests pass. At least 25 @test assertions covering happy path loading, missing file handling, and JSON format support.
  </verify>
  <done>
All five reference data loaders (cost, PLD, thermal dispatch, hydro dispatch, hydro storage) load CSV files correctly, support JSON format, and return nothing gracefully for missing files. Tests pass with correct DataFrame schemas validated.
  </done>
</task>

</tasks>

<verification>
1. `julia --project=test -e 'include("test/validation/test_validation_types.jl")'` -- all pass
2. `julia --project=test -e 'include("test/validation/test_reference_loader.jl")'` -- all pass
3. All validation structs have docstrings
4. Reference loaders handle missing files gracefully (return nothing, not error)
5. Both CSV and JSON formats supported
</verification>

<success_criteria>
- ValidationResult struct supports full introspection (per-metric pass/fail, detailed comparisons, exit code)
- MetricComparison, PLDComparison, DispatchComparison structs construct correctly
- validation_exit_code() returns correct codes per CONTEXT.md (0/1/2/3)
- All 5 reference data loaders work with CSV format (cost, PLD, thermal dispatch, hydro dispatch, hydro storage)
- JSON format supported for all loaders
- Missing files handled gracefully (return nothing)
- 55+ test assertions pass across both test files
</success_criteria>

<output>
After completion, create `.planning/phases/05-end-to-end-validation/05-01-SUMMARY.md`
</output>
