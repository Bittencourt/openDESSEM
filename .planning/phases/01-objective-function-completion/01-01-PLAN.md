---
phase: 01-objective-function-completion
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/data/loaders/fcf_loader.jl
  - test/unit/test_fcf_loader.jl
autonomous: true

must_haves:
  truths:
    - "FCF curves can be loaded from infofcf.dat files"
    - "Water values are retrievable by plant ID and storage level"
    - "FCF data validates correctly with proper error messages"
  artifacts:
    - path: "src/data/loaders/fcf_loader.jl"
      provides: "FCF curve parsing and water value lookup"
      exports: ["load_fcf_curves", "get_water_value", "FCFCurve", "FCFCurveData"]
      min_lines: 100
    - path: "test/unit/test_fcf_loader.jl"
      provides: "Test coverage for FCF loading"
      min_lines: 80
  key_links:
    - from: "src/data/loaders/fcf_loader.jl"
      to: "src/objective/production_cost.jl"
      via: "FCFCurveData struct used in objective"
      pattern: "FCFCurveData"
---

<objective>
Implement FCF (Future Cost Function) curve loader to read water value data from infofcf.dat files.

Purpose: The FCF curves provide the opportunity cost of water usage, enabling the optimization to value stored water at terminal periods correctly. Without FCF curves, the objective function uses hardcoded water values that don't reflect actual system marginal water costs.

Output: New module `src/data/loaders/fcf_loader.jl` with complete parsing and test coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/data/loaders/dessem_loader.jl
@src/entities/hydro.jl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FCF data structures</name>
  <files>src/data/loaders/fcf_loader.jl</files>
  <action>
Create new file `src/data/loaders/fcf_loader.jl` with:

1. **FCFCurve struct** - Single plant's FCF curve:
   - `plant_id::String` - Hydro plant identifier
   - `num_pieces::Int` - Number of piecewise linear segments
   - `storage_breakpoints::Vector{Float64}` - Storage levels (hm3) at breakpoints
   - `water_values::Vector{Float64}` - Water values (R$/hm3) at each breakpoint
   - Validation: num_pieces == length(storage_breakpoints) == length(water_values)

2. **FCFCurveData struct** - Container for all plant curves:
   - `curves::Dict{String, FCFCurve}` - Mapping plant_id -> FCFCurve
   - `study_date::Date` - Base date for the study period
   - `num_periods::Int` - Number of time periods (typically 168 for weekly)
   - Method `get_water_value(plant_id, storage_level)` -> interpolated water value

3. **Follow existing patterns** from dessem_loader.jl:
   - Use `Base.@kwdef` for structs with defaults
   - Include comprehensive docstrings with examples
   - Validate on construction with clear error messages
   - Use 4-space indentation, 92-char line limit
  </action>
  <verify>
File exists at src/data/loaders/fcf_loader.jl with:
- FCFCurve struct with fields: plant_id, num_pieces, storage_breakpoints, water_values
- FCFCurveData struct with fields: curves, study_date, num_periods
- get_water_value function with docstring
- All exports declared
  </verify>
  <done>
FCF data structures defined with validation, matching existing loader patterns.
</done>
</task>

<task type="auto">
  <name>Task 2: Implement infofcf.dat parser</name>
  <files>src/data/loaders/fcf_loader.jl</files>
  <action>
Add to fcf_loader.jl:

1. **Function `parse_infofcf_file(filepath::String) -> FCFCurveData`**:
   - Read infofcf.dat file (FIX-format DESSEM file)
   - Expected format (typical DESSEM INFOFCF):
     - Header line with study info
     - For each plant: lines with (posto, num_pieces, then pairs of storage/value)
     - May include period index for multi-period FCF
   - Handle missing files gracefully with informative error
   - Log parsing progress with @info

2. **Function `parse_fcf_line(line::String) -> Union{FCFCurve, Nothing}`**:
   - Parse single FCF record line
   - Handle variable spacing (FIX format)
   - Return FCFCurve or nothing if invalid

3. **Function `load_fcf_curves(path::String) -> FCFCurveData`**:
   - Main entry point - loads from directory containing infofcf.dat
   - Also try alternate filenames: INFOFCF.DAT, fcf.dat, FCF.DAT
   - Return FCFCurveData with all curves loaded

4. **Helper `interpolate_water_value(curve, storage)`**:
   - Linear interpolation between breakpoints
   - Clamp storage to [min, max] range
   - Return water value in R$/hm3
  </action>
  <verify>
Functions exist:
- parse_infofcf_file(filepath) -> FCFCurveData
- load_fcf_curves(path) -> FCFCurveData
- get_water_value(fcfcf_data, plant_id, storage) -> Float64
All functions have docstrings with examples.
  </verify>
  <done>
Parser reads infofcf.dat files and returns FCFCurveData with interpolated water value lookup.
</done>
</task>

<task type="auto">
  <name>Task 3: Create comprehensive test suite</name>
  <files>test/unit/test_fcf_loader.jl</files>
  <action>
Create `test/unit/test_fcf_loader.jl` with test coverage:

1. **FCFCurve struct tests**:
   - Valid construction with piecewise data
   - Validation rejects mismatched array lengths
   - Empty curves handled appropriately

2. **FCFCurveData container tests**:
   - Add and retrieve curves by plant_id
   - get_water_value returns correct interpolation
   - Extrapolation clamps to nearest breakpoint

3. **Parser tests** (with sample data strings):
   - Parse valid infofcf.dat content
   - Handle missing files with proper error
   - Handle malformed lines gracefully

4. **Integration test**:
   - Create mock FCF file, parse it, verify water values
   - Test interpolation at various storage levels

Follow existing test patterns from test/unit/test_variable_manager.jl:
- Use @testset blocks for organization
- Include both positive and error cases
- Aim for >90% coverage of new code
  </action>
  <verify>
Run: julia --project=test -e 'include("test/unit/test_fcf_loader.jl")'
All tests pass with >90% coverage of fcf_loader.jl
  </verify>
  <done>
Test file exists with comprehensive coverage of FCFCurve, FCFCurveData, and parsing functions.
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `julia --project=test test/runtests.jl` includes FCF loader tests and passes
2. FCF loader can parse sample infofcf.dat format
3. Water value interpolation works correctly
</verification>

<success_criteria>
- FCFCurve and FCFCurveData structs defined with validation
- load_fcf_curves() function parses infofcf.dat files
- get_water_value() returns interpolated water values
- Test coverage >90% for new module
- Code follows project style (4-space indent, 92-char lines, JuliaFormatter clean)
</success_criteria>

<output>
After completion, create `.planning/phases/01-objective-function-completion/01-01-SUMMARY.md`
</output>
