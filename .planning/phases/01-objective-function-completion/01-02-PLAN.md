---
phase: 01-objective-function-completion
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/variables/variable_manager.jl
  - test/unit/test_variable_manager.jl
autonomous: true

must_haves:
  truths:
    - "Load shedding variables are created in the JuMP model"
    - "Deficit variables are created per submarket per time period"
    - "Variables are accessible via model[:shed] and model[:deficit]"
  artifacts:
    - path: "src/variables/variable_manager.jl"
      provides: "Load shedding and deficit variable creation"
      exports: ["create_load_shedding_variables!", "create_deficit_variables!"]
      contains: "create_load_shedding_variables!"
    - path: "test/unit/test_variable_manager.jl"
      provides: "Test coverage for new variable types"
  key_links:
    - from: "src/variables/variable_manager.jl"
      to: "src/objective/production_cost.jl"
      via: "model[:shed] and model[:deficit] in objective"
      pattern: ":shed|:deficit"
---

<objective>
Add load shedding and deficit penalty variables to the VariableManager module.

Purpose: Load shedding variables allow the optimization to shed load when generation is insufficient, with a penalty cost. Deficit variables track unmet demand by submarket. Both are required for a complete objective function that can handle supply scarcity scenarios.

Output: Extended variable_manager.jl with create_load_shedding_variables!() and create_deficit_variables!() functions, plus test coverage.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/variables/variable_manager.jl
@src/entities/market.jl
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add create_load_shedding_variables! function</name>
  <files>src/variables/variable_manager.jl</files>
  <action>
Add to src/variables/variable_manager.jl (after create_renewable_variables!):

1. **Function `create_load_shedding_variables!`**:
```julia
"""
    create_load_shedding_variables!(
        model::Model,
        system::ElectricitySystem,
        time_periods::Union{UnitRange{Int}, Vector{Int}};
        load_ids::Union{Nothing, Vector{String}} = nothing
    )

Create load shedding penalty variables.

Creates:
- `shed[l, t]`: Load shedding (MW) for load l at time t, >= 0

Load shedding represents demand that cannot be met by available generation.
High penalty costs in objective ensure shedding only occurs as last resort.

# Arguments
- model::Model: JuMP model
- system::ElectricitySystem: System with loads
- time_periods: Time periods
- load_ids: Optional specific load IDs to create variables for

# Example
create_load_shedding_variables!(model, system, 1:168)
shed = model[:shed]  # Access shedding variable
"""
```

2. **Implementation details**:
   - Index by load index (1:n_loads) and time period
   - Variable is continuous, lower bound 0
   - No upper bound (constraint will limit by load demand)
   - Skip if no loads in system

3. **Add to exports**: Add `create_load_shedding_variables!` to module export list

4. **Update create_all_variables!**: Add call to create_load_shedding_variables!
  </action>
  <verify>
Function create_load_shedding_variables! exists with:
- Docstring explaining variable semantics
- Creates model[:shed] with dimensions (n_loads, n_periods)
- Exported in module
- Called from create_all_variables!
  </verify>
  <done>
Load shedding variables created and accessible via model[:shed].
</done>
</task>

<task type="auto">
  <name>Task 2: Add create_deficit_variables! function</name>
  <files>src/variables/variable_manager.jl</files>
  <action>
Add to src/variables/variable_manager.jl (after create_load_shedding_variables!):

1. **Function `create_deficit_variables!`**:
```julia
"""
    create_deficit_variables!(
        model::Model,
        system::ElectricitySystem,
        time_periods::Union{UnitRange{Int}, Vector{Int}};
        submarket_ids::Union{Nothing, Vector{String}} = nothing
    )

Create energy deficit variables per submarket.

Creates:
- `deficit[s, t]`: Energy deficit (MW) in submarket s at time t, >= 0

Deficit represents unmet demand at the submarket level. Different from
load shedding - deficit is per-submarket aggregate, shedding is per-load.

# Arguments
- model::Model: JuMP model
- system::ElectricitySystem: System with submarkets
- time_periods: Time periods
- submarket_ids: Optional specific submarket IDs

# Example
create_deficit_variables!(model, system, 1:168)
deficit = model[:deficit]  # Access deficit variable
"""
```

2. **Implementation details**:
   - Index by submarket index (1:n_submarkets) and time period
   - Variable is continuous, lower bound 0
   - Use system.submarkets for indexing
   - Skip if no submarkets

3. **Add helper function** `get_submarket_indices(system::ElectricitySystem)`:
   - Similar to get_thermal_plant_indices
   - Returns Dict{String, Int} mapping submarket.code -> index

4. **Add to exports**: Add `create_deficit_variables!`, `get_submarket_indices` to exports

5. **Update create_all_variables!**: Add call to create_deficit_variables!
  </action>
  <verify>
Function create_deficit_variables! exists with:
- Docstring explaining variable semantics
- Creates model[:deficit] with dimensions (n_submarkets, n_periods)
- Helper get_submarket_indices exists
- Exported in module
- Called from create_all_variables!
  </verify>
  <done>
Deficit variables created and accessible via model[:deficit].
</done>
</task>

<task type="auto">
  <name>Task 3: Add test coverage for new variables</name>
  <files>test/unit/test_variable_manager.jl</files>
  <action>
Add to test/unit/test_variable_manager.jl:

1. **Test create_load_shedding_variables!**:
   - Create model with loads, call function
   - Verify model[:shed] exists with correct dimensions
   - Verify variables have correct bounds (>= 0)
   - Test with empty loads (should not error)
   - Test with load_ids filter

2. **Test create_deficit_variables!**:
   - Create model with submarkets, call function
   - Verify model[:deficit] exists with correct dimensions
   - Verify variables have correct bounds
   - Test with empty submarkets
   - Test with submarket_ids filter

3. **Test get_submarket_indices**:
   - Returns correct mapping for system submarkets
   - Returns empty Dict if no submarkets

4. **Test create_all_variables! includes new variables**:
   - After calling create_all_variables!, verify :shed and :deficit exist
   - Verify all variables created together work correctly

Follow existing test patterns in the file (use @testset blocks).
  </action>
  <verify>
Run: julia --project=test -e 'include("test/unit/test_variable_manager.jl")'
All new tests pass, existing tests still pass
  </verify>
  <done>
Test coverage added for load shedding and deficit variables with all tests passing.
</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `julia --project=test test/runtests.jl` passes with new tests
2. model[:shed] accessible after create_load_shedding_variables!
3. model[:deficit] accessible after create_deficit_variables!
4. create_all_variables! creates both new variable types
</verification>

<success_criteria>
- create_load_shedding_variables! creates model[:shed] indexed by (load, time)
- create_deficit_variables! creates model[:deficit] indexed by (submarket, time)
- get_submarket_indices helper function exists
- Both functions exported from Variables module
- Test coverage for new functions
- Code follows project style conventions
</success_criteria>

<output>
After completion, create `.planning/phases/01-objective-function-completion/01-02-SUMMARY.md`
</output>
